/////////////////////////////////////////////////////////////////////
// How to use the COM object.
/////////////////////////////////////////////////////////////////////
1) The client should call the following to initialize the COM DLL from
   the main process _and_ from any thread that will be using COM:

	::CoInitializeEx(
		NULL,				//always NULL
		COINIT_APARTMENTTHREADED	//see book about threading models
		);

	NOTE: You also need to add _WIN32_DCOM to your project settings under 
	"Preprocessor definitions" in order to get the prototype definition for
	::CoInitializeEx() included in your compile.

2) Create a guids.h file that contains the class and interface ID's of
   the COM classes you want to create. You can find these in the *_i.c
   file generated by the MIDL compiler:

#if !defined guids_h
#define guids_h

const IID CLSID_IWzdSrv = { 0x4487d432, 0xa6ff, 0x11d3, 0xa3, 0x98, 0x0, 0xc0, 0x4f, 0x57, 0xe, 0x2c };
const IID IID_IWzd = {0xC177116E,0x9AAA,0x11D3,{0x80,0x5D,0x00,0x00,0x00,0x00,0x00,0x00}};

#endif 


3) Include this guids.h file as well as the COM class's .h file (also generated by MIDL) and
   an MFC .h file:

#include "IServer\IWzd.h"
#include "guids.h"
#include <objbase.h>

4) To create a COM object one at a time, use:

	IWzd *iWzd=NULL;
	HRESULT hr=::CoCreateInstance(
				CLSID_IWzdSrv,		// name of dll to load
				NULL,				// aggregated COM object (none)
				CLSCTX_INPROC_SERVER,// use dll
				IID_IWzd,			// class to create and object of
				(LPVOID*) &iWzd);	// returned object pointer
	if (FAILED(hr))
	{
		_com_error err(hr);
		AfxMessageBox(err.ErrorMessage());
		return;
	}
	iWzd->Release();

5) To call what CoCreateInstance() calls directly for diagnostic reasons, use:

	// load DLL/EXE and get a pointer to its class factory
	IClassFactory *pCF=NULL;
	hr=::CoGetClassObject(
				CLSID_IWzdSrv,		// name of dll to load
				CLSCTX_INPROC_SERVER,// use dll
				NULL,				// for DCOM, a COSERVERINFO structure that id's the remote server
									// more typically set using OLEView
				IID_IClassFactory,	// the class factory interface (all COM DLL/EXE's must have this interface)
				(LPVOID*)&pCF); 
	if (FAILED(hr))
	{
		_com_error err(hr);
		AfxMessageBox(err.ErrorMessage());
		return;
	}
	// ask class factory to creat the class
	hr = pCF->CreateInstance(
				NULL,				// aggregated COM object (none)
				IID_IWzd,			// class to create and object of
				(LPVOID*) &iWzd);	// returned object pointer
	if (FAILED(hr))
	{
		_com_error err(hr);
		AfxMessageBox(err.ErrorMessage());
		return;
	}
	pCF->Release(); 
	iWzd->Release(); 

6) To create multiple COM objects at once use:
 
	// setup MULTI_QI structure with all the classes to create
	MULTI_QI results[3];
	memset(results,0,sizeof(results));
	results[0].pIID=&IID_IWzd;	// class to create 
	results[1].pIID=&IID_IWzd;	
	results[2].pIID=&IID_IWzd;	

	// make the call
	hr =::CoCreateInstanceEx(
				CLSID_IWzdSrv,		// name of dll to load
				NULL,				// aggregated COM object (none)
				CLSCTX_INPROC_SERVER,// use dll
				NULL,				// for DCOM, a COSERVERINFO structure that id's the remote server
									// more typically set using OLEView
				3,					// number of MULTI_QI structures in results
				(MULTI_QI*)&results); // array of MULTI_QI structures
	if (FAILED(hr))
	{
		_com_error err(hr);
		AfxMessageBox(err.ErrorMessage());
		return;
	}
	for (int i=0;i<3;i++)
	{
		if (FAILED(results[i].hr))
		{
			_com_error err(hr);
			AfxMessageBox(err.ErrorMessage());
		}
	}
	IWzd *iWzd1=(IWzd*)results[0].pItf;
	IWzd *iWzd2=(IWzd*)results[1].pItf;
	IWzd *iWzd3=(IWzd*)results[2].pItf;
	iWzd1->Release();
	iWzd2->Release();
	iWzd3->Release();


/////////////////////////////////////////////////////////////////////
// From: COM Programming by Example by John E. Swanke
// Copyright (C) 2000 jeswanke. All rights reserved.
/////////////////////////////////////////////////////////////////////

