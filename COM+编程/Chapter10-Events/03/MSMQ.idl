// Generated .IDL file (by the OLE/COM Object Viewer)
// 
// typelib filename: MQOA.DLL

[
  uuid(D7D6E071-DCCD-11D0-AA4B-0060970DEBAE),
  version(2.0),
  helpstring("Microsoft Message Queue 2.0 Object Library"),
  custom(DE77BA64-517C-11D1-A2DA-0000F8773CE9, 84082967),
  custom(DE77BA63-517C-11D1-A2DA-0000F8773CE9, 940427399)

]
library MSMQ
{
    // TLib :     // TLib : OLE Automation : {00020430-0000-0000-C000-000000000046}
    importlib("stdole2.tlb");

    // Forward declare all types defined in this typelib
    interface IMSMQQuery;
    interface IMSMQQueueInfos;
    interface IMSMQQueueInfo;
    interface IMSMQQueue;
    interface IMSMQMessage;
    interface IMSMQEvent;
    interface IMSMQQueueInfo2;
    interface IMSMQQueue2;
    interface IMSMQEvent2;
    interface IMSMQMessage2;
    interface IMSMQQueueInfos2;
    interface IMSMQTransaction;
    interface IMSMQCoordinatedTransactionDispenser;
    interface IMSMQTransactionDispenser;
    interface IMSMQQuery2;
    interface IMSMQPrivateEvent;
    dispinterface _DMSMQEventEvents;
    interface IMSMQTransaction2;
    interface IMSMQCoordinatedTransactionDispenser2;
    interface IMSMQTransactionDispenser2;
    interface IMSMQApplication;
    interface IMSMQApplication2;

    [
      odl,
      uuid(D7D6E072-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Interface providing Message Queuing lookup facilities that are used to locate public queues."),
      hidden,
      dual,
      nonextensible,
      oleautomation
    ]
    interface IMSMQQuery : IDispatch {
        [id(0x60020000), helpstring("Produces a collection of public queues that match a specified selection criteria. Queries Active Directory.")]
        HRESULT LookupQueue(
                        [in, optional] VARIANT* QueueGuid, 
                        [in, optional] VARIANT* ServiceTypeGuid, 
                        [in, optional] VARIANT* Label, 
                        [in, optional] VARIANT* CreateTime, 
                        [in, optional] VARIANT* ModifyTime, 
                        [in, optional] VARIANT* RelServiceType, 
                        [in, optional] VARIANT* RelLabel, 
                        [in, optional] VARIANT* RelCreateTime, 
                        [in, optional] VARIANT* RelModifyTime, 
                        [out, retval] IMSMQQueueInfos** ppqinfos);
    };

    [
      odl,
      uuid(D7D6E07D-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Interface describing the collection of queues produced by MSMQQuery.LookupQueue."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQQueueInfos : IDispatch {
        [id(0x60020000), helpstring("Method used to reset the implicit cursor to the start of a collection of queues produced by MSMQQuery.LookupQueue.")]
        HRESULT Reset();
        [id(0x60020001), helpstring("Method used to advance the implicit cursor to the next element of a collection of queues produced by MSMQQuery.LookupQueue.")]
        HRESULT Next([out, retval] IMSMQQueueInfo** ppqinfoNext);
    };

    [
      odl,
      uuid(D7D6E07B-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Interface describing a queue."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQQueueInfo : IDispatch {
        [id(00000000), propget, helpstring("Property indicating the identifier of the public queue.")]
        HRESULT QueueGuid([out, retval] BSTR* pbstrGuidQueue);
        [id(0x00000001), propget, helpstring("Property identifying the type of service provided by the queue.")]
        HRESULT ServiceTypeGuid([out, retval] BSTR* pbstrGuidServiceType);
        [id(0x00000001), propput, helpstring("Property identifying the type of service provided by the queue.")]
        HRESULT ServiceTypeGuid([in] BSTR pbstrGuidServiceType);
        [id(0x00000002), propget, helpstring("Property indicating the label of the queue.")]
        HRESULT Label([out, retval] BSTR* pbstrLabel);
        [id(0x00000002), propput, helpstring("Property indicating the label of the queue.")]
        HRESULT Label([in] BSTR pbstrLabel);
        [id(0x00000003), propget, helpstring("Property indicating the pathname (physical location) of the queue.")]
        HRESULT PathName([out, retval] BSTR* pbstrPathName);
        [id(0x00000003), propput, helpstring("Property indicating the pathname (physical location) of the queue.")]
        HRESULT PathName([in] BSTR pbstrPathName);
        [id(0x00000005), propget, helpstring("Property that identifies the queue. The format name of a queue is generated by MSMQ when the queue is created, or generated later by the application.")]
        HRESULT FormatName([out, retval] BSTR* pbstrFormatName);
        [id(0x00000005), propput, helpstring("Property that identifies the queue. The format name of a queue is generated by MSMQ when the queue is created, or generated later by the application.")]
        HRESULT FormatName([in] BSTR pbstrFormatName);
        [id(0x00000006), propget, helpstring("Property indicating whether the queue is transactional or non-transactional. If the queue is transactional, all messages sent to the queue must be part of a transaction.")]
        HRESULT IsTransactional([out, retval] short* pisTransactional);
        [id(0x00000007), propget, helpstring("Property that specifies the privacy level that is required by the queue. The privacy level determines how the queue handles private (encrypted) messages. Possible values are defined by the MQPRIVLEVEL enumeration.")]
        HRESULT PrivLevel([out, retval] long* plPrivLevel);
        [id(0x00000007), propput, helpstring("Property that specifies the privacy level that is required by the queue. The privacy level determines how the queue handles private (encrypted) messages. Possible values are defined by the MQPRIVLEVEL enumeration.")]
        HRESULT PrivLevel([in] long plPrivLevel);
        [id(0x00000008), propget, helpstring("Property that specifies if the messages retrieved from the queue are copied to the queue's journal queue.  Possible values are defined by the MQJOURNAL enumeration.")]
        HRESULT Journal([out, retval] long* plJournal);
        [id(0x00000008), propput, helpstring("Property that specifies if the messages retrieved from the queue are copied to the queue's journal queue.  Possible values are defined by the MQJOURNAL enumeration.")]
        HRESULT Journal([in] long plJournal);
        [id(0x0000000d), propget, helpstring("Property that specifies the maximum size (in kilobytes) of the queue.")]
        HRESULT Quota([out, retval] long* plQuota);
        [id(0x0000000d), propput, helpstring("Property that specifies the maximum size (in kilobytes) of the queue.")]
        HRESULT Quota([in] long plQuota);
        [id(0x00000009), propget, helpstring("Property that specifies the base priority for all messages sent to a public queue.  The queue's base priority has no effect on the order of the messages in the queue, or how messages are read from the queue.")]
        HRESULT BasePriority([out, retval] long* plBasePriority);
        [id(0x00000009), propput, helpstring("Property that specifies the base priority for all messages sent to a public queue.  The queue's base priority has no effect on the order of the messages in the queue, or how messages are read from the queue.")]
        HRESULT BasePriority([in] long plBasePriority);
        [id(0x0000000a), propget, helpstring("Property that indicates the time and date when the queue was created. The type is Variant Date.")]
        HRESULT CreateTime([out, retval] VARIANT* pvarCreateTime);
        [id(0x0000000b), propget, helpstring("Property that indicates the time and date when the queue's properties were last modified. The type is Variant Date.")]
        HRESULT ModifyTime([out, retval] VARIANT* pvarModifyTime);
        [id(0x0000000c), propget, helpstring("Property that specifies whether or not the queue only accepts authenticated messages.  If the authentication level of the message does not match the authentication level of the queue, the message is rejected by the queue.  Possible values are defined by the MQAUTHENTICATE enumeration.")]
        HRESULT Authenticate([out, retval] long* plAuthenticate);
        [id(0x0000000c), propput, helpstring("Property that specifies whether or not the queue only accepts authenticated messages.  If the authentication level of the message does not match the authentication level of the queue, the message is rejected by the queue.  Possible values are defined by the MQAUTHENTICATE enumeration.")]
        HRESULT Authenticate([in] long plAuthenticate);
        [id(0x0000000e), propget, helpstring("Property that specifies the maximum size (in kilobytes) of the journal queue.")]
        HRESULT JournalQuota([out, retval] long* plJournalQuota);
        [id(0x0000000e), propput, helpstring("Property that specifies the maximum size (in kilobytes) of the journal queue.")]
        HRESULT JournalQuota([in] long plJournalQuota);
        [id(0x0000000f), propget, helpstring("Property that indicates who can read messages in the queue. If set to False (the default), all users can send messages to the queue but only the owner of the queue can read messages from it. If set to True,  all users can read messages from the queue.")]
        HRESULT IsWorldReadable([out, retval] short* pisWorldReadable);
        [id(0x60020019), helpstring("Method used to create a new queue. The PathName property is required to create a queue. The FormatName property is updated when the queue is created.  Optional parameters include IsWorldReadable (default set to False) and IsTransactional (default set to False).")]
        HRESULT Create(
                        [in, optional] VARIANT* IsTransactional, 
                        [in, optional] VARIANT* IsWorldReadable);
        [id(0x6002001a), helpstring("Method used to delete queue. The PathName propety must be specified to delete a queue.")]
        HRESULT Delete();
        [id(0x6002001b), helpstring("Method used to open a queue. The PathName property must be specified to open a queue. Parameters include Access (send, peek, or receive) and ShareMode (exclusive or all).")]
        HRESULT Open(
                        [in] long Access, 
                        [in] long ShareMode, 
                        [out, retval] IMSMQQueue** ppq);
        [id(0x6002001c), helpstring("Method used to refresh the properties of a public queue from Active Directory.")]
        HRESULT Refresh();
        [id(0x6002001d), helpstring("Method used to update Active Directory with the public queue's current properties.")]
        HRESULT Update();
    };

    [
      odl,
      uuid(D7D6E076-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Interface describing an open queue that supports message retrieval.  Obtained by invoking the MSMQQueueInfo.Open method."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQQueue : IDispatch {
        [id(0x00000001), propget, helpstring("Property indicating the access mode of a queue. Possible values are defined by MQACCESS enumeration.")]
        HRESULT Access([out, retval] long* plAccess);
        [id(0x00000002), propget, helpstring("Property indicating the share mode of a queue. Possible values are defined by MQSHARE enumeration.")]
        HRESULT ShareMode([out, retval] long* plShareMode);
        [id(0x00000003), propget, helpstring("Property referring to an MSMQQueueInfo instance describing the queue.")]
        HRESULT QueueInfo([out, retval] IMSMQQueueInfo** ppqinfo);
        [id(00000000), propget, helpstring("Property indicating the internal handle of an open queue instance.  Useful for directly calling Message Queuing APIs.")]
        HRESULT Handle([out, retval] long* plHandle);
        [id(0x00000004), propget, helpstring("Property indicating whether or not the queue object refers to an open instance of a queue.")]
        HRESULT IsOpen([out, retval] short* pisOpen);
        [id(0x60020005), helpstring("Method to close an open instance of a queue.")]
        HRESULT Close();
        [id(0x60020006), helpstring("Method to synchronously retrieve a message from a queue. It always removes the first message in the queue regardless of the position of the implicit cursor. Optional parameters include ReceiveTimeout (default set to INFINITE), Transaction (default set to MTS Transaction), WantDestinationQueue (default set to False), and WantBody (default set to True).")]
        HRESULT Receive(
                        [in, optional] VARIANT* Transaction, 
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [out, retval] IMSMQMessage** ppmsg);
        [id(0x60020007), helpstring("Method to synchronously peek at the first message in the queue, regardless of the implicit cursor position. Optional parameters include ReceiveTimeout (default set to INFINITE), WantDestinationQueue (default set to False), and WantBody (default set to True).")]
        HRESULT Peek(
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [out, retval] IMSMQMessage** ppmsg);
        [id(0x60020008), helpstring("Method to enable asynchronous notification of arriving messages. It can use the queue's implicit cursor.  The user-defined MSMQEvent_Arrived event handler is invoked when a message arrives at the location specified by the optional Cursor parameter (default is first message in the queue), or a timeout occurs. The user-defined MSMQEvent_ArrivedError is invoked if the asynchronous message retrieval results in an error.")]
        HRESULT EnableNotification(
                        [in] IMSMQEvent* Event, 
                        [in, optional] VARIANT* Cursor, 
                        [in, optional] VARIANT* ReceiveTimeout);
        [id(0x60020009), helpstring("Method that resets the queue's implicit cursor to the beginning of the queue.")]
        HRESULT Reset();
        [id(0x6002000a), helpstring("Method to synchronously remove the current message from the queue. Retrieves the message at the position pointed to by the implicit cursor. Optional parameters include ReceiveTimeout (default set to INFINITE), Transaction (default set to MTS Transaction), WantDestinationQueue (default set to False), and WantBody (default set to True).")]
        HRESULT ReceiveCurrent(
                        [in, optional] VARIANT* Transaction, 
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [out, retval] IMSMQMessage** ppmsg);
        [id(0x6002000b), helpstring("Method to synchronously peek at the next message in the queue. When called, the implicit cursor is first advanced and then the message is returned. Optional parameters include ReceiveTimeout (default set to INFINITE), WantDestinationQueue (default set to False), and WantBody (default set to True).")]
        HRESULT PeekNext(
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [out, retval] IMSMQMessage** ppmsg);
        [id(0x6002000c), helpstring("Method to synchronously peek at the current message in the queue (the message pointed at by the implicit cursor). The implicit cursor is not advanced. Optional parameters include ReceiveTimeout (default set to INFINITE), WantDestinationQueue (default set to False), and WantBody (default set to True).")]
        HRESULT PeekCurrent(
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [out, retval] IMSMQMessage** ppmsg);
    };

    [
      odl,
      uuid(D7D6E074-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Interface describing a message. A message can be created and sent to a queue or obtained from a queue."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQMessage : IDispatch {
        [id(0x00000007), propget, helpstring("Property indicating the class of message. Possible values are defined by MQMSGCLASS enumeration")]
        HRESULT Class([out, retval] long* plClass);
        [id(0x00000019), propget, helpstring("Property indicating the privacy level of a message.  Possible values are defined by MQMSGPRIVLEVEL enumeration.")]
        HRESULT PrivLevel([out, retval] long* plPrivLevel);
        [id(0x00000019), propput, helpstring("Property indicating the privacy level of a message.  Possible values are defined by MQMSGPRIVLEVEL enumeration.")]
        HRESULT PrivLevel([in] long plPrivLevel);
        [id(0x0000001a), propget, helpstring("Property indicating the authorization level of a message. Possible values are defined by MQMSGAUTHLEVEL enumeration.")]
        HRESULT AuthLevel([out, retval] long* plAuthLevel);
        [id(0x0000001a), propput, helpstring("Property indicating the authorization level of a message. Possible values are defined by MQMSGAUTHLEVEL enumeration.")]
        HRESULT AuthLevel([in] long plAuthLevel);
        [id(0x0000001b), propget, helpstring("Property indicating whether a message was authenticated or not.")]
        HRESULT IsAuthenticated([out, retval] short* pisAuthenticated);
        [id(0x00000001), propget, helpstring("Property indicating the delivery mode of a message. Possible values defined by MQMSGDELIVERY enumeration.")]
        HRESULT Delivery([out, retval] long* plDelivery);
        [id(0x00000001), propput, helpstring("Property indicating the delivery mode of a message. Possible values defined by MQMSGDELIVERY enumeration.")]
        HRESULT Delivery([in] long plDelivery);
        [id(0x00000018), propget, helpstring("Property indicating the tracing option for a message. Possible values are defined by MQMSGTRACE enumeration.")]
        HRESULT Trace([out, retval] long* plTrace);
        [id(0x00000018), propput, helpstring("Property indicating the tracing option for a message. Possible values are defined by MQMSGTRACE enumeration.")]
        HRESULT Trace([in] long plTrace);
        [id(0x00000002), propget, helpstring("Property indicating the priority level of a message. The range must be between MQ_MIN_PRIORITY and MQ_MAX_PRIORITY.")]
        HRESULT Priority([out, retval] long* plPriority);
        [id(0x00000002), propput, helpstring("Property indicating the priority level of a message. The range must be between MQ_MIN_PRIORITY and MQ_MAX_PRIORITY.")]
        HRESULT Priority([in] long plPriority);
        [id(0x00000003), propget, helpstring("Property indicating the journaling option for a message.  Possible values are defined by MQMSGJOURNAL enumeration.")]
        HRESULT Journal([out, retval] long* plJournal);
        [id(0x00000003), propput, helpstring("Property indicating the journaling option for a message.  Possible values are defined by MQMSGJOURNAL enumeration.")]
        HRESULT Journal([in] long plJournal);
        [id(0x00000004), propget, helpstring("Property indicating the response queue for the message.")]
        HRESULT ResponseQueueInfo([out, retval] IMSMQQueueInfo** ppqinfoResponse);
        [id(0x00000004), propputref, helpstring("Property indicating the response queue for the message.")]
        HRESULT ResponseQueueInfo([in] IMSMQQueueInfo* ppqinfoResponse);
        [id(0x00000005), propget, helpstring("Property containing application-specific information.")]
        HRESULT AppSpecific([out, retval] long* plAppSpecific);
        [id(0x00000005), propput, helpstring("Property containing application-specific information.")]
        HRESULT AppSpecific([in] long plAppSpecific);
        [id(0x00000006), propget, helpstring("Property identifying the computer where the message originated.")]
        HRESULT SourceMachineGuid([out, retval] BSTR* pbstrGuidSrcMachine);
        [id(0x0000000d), propget, helpstring("Property indicating the length (in bytes) of the message body.")]
        HRESULT BodyLength([out, retval] long* pcbBody);
        [id(00000000), propget, helpstring("Property containing the message body.  It is of Variant type and can contain any intrinsic type and persistent object.")]
        HRESULT Body([out, retval] VARIANT* pvarBody);
        [id(00000000), propput, helpstring("Property containing the message body.  It is of Variant type and can contain any intrinsic type and persistent object.")]
        HRESULT Body([in] VARIANT pvarBody);
        [id(0x00000008), propget, helpstring("Property indicating the administration queue for the message.")]
        HRESULT AdminQueueInfo([out, retval] IMSMQQueueInfo** ppqinfoAdmin);
        [id(0x00000008), propputref, helpstring("Property indicating the administration queue for the message.")]
        HRESULT AdminQueueInfo([in] IMSMQQueueInfo* ppqinfoAdmin);
        [id(0x00000009), propget, helpstring("Property containing the MSMQ-generated identifier (array of bytes) for the message.")]
        HRESULT Id([out, retval] VARIANT* pvarMsgId);
        [id(0x0000000a), propget, helpstring("Property indicating the correlation identifier (array of bytes) for the message.")]
        HRESULT CorrelationId([out, retval] VARIANT* pvarMsgId);
        [id(0x0000000a), propput, helpstring("Property indicating the correlation identifier (array of bytes) for the message.")]
        HRESULT CorrelationId([in] VARIANT pvarMsgId);
        [id(0x0000000b), propget, helpstring("Property indicating what kind of acknowledgement message is returned. Possible values are defined by MQMSGACKNOWLEDGEMENT enumeration.")]
        HRESULT Ack([out, retval] long* plAck);
        [id(0x0000000b), propput, helpstring("Property indicating what kind of acknowledgement message is returned. Possible values are defined by MQMSGACKNOWLEDGEMENT enumeration.")]
        HRESULT Ack([in] long plAck);
        [id(0x0000000c), propget, helpstring("Property indicating the label of the message.")]
        HRESULT Label([out, retval] BSTR* pbstrLabel);
        [id(0x0000000c), propput, helpstring("Property indicating the label of the message.")]
        HRESULT Label([in] BSTR pbstrLabel);
        [id(0x0000000e), propget, helpstring("Property indicating the amount of time allowed to deliver the message to its destination queue.")]
        HRESULT MaxTimeToReachQueue([out, retval] long* plMaxTimeToReachQueue);
        [id(0x0000000e), propput, helpstring("Property indicating the amount of time allowed to deliver the message to its destination queue.")]
        HRESULT MaxTimeToReachQueue([in] long plMaxTimeToReachQueue);
        [id(0x0000000f), propget, helpstring("Property indicating the amount of time the receiving application has to retreive the message from its destination queue.")]
        HRESULT MaxTimeToReceive([out, retval] long* plMaxTimeToReceive);
        [id(0x0000000f), propput, helpstring("Property indicating the amount of time the receiving application has to retreive the message from its destination queue.")]
        HRESULT MaxTimeToReceive([in] long plMaxTimeToReceive);
        [id(0x00000011), propget, helpstring("Property indicating which hash algorithm to use when authenticating the message.")]
        HRESULT HashAlgorithm([out, retval] long* plHashAlg);
        [id(0x00000011), propput, helpstring("Property indicating which hash algorithm to use when authenticating the message.")]
        HRESULT HashAlgorithm([in] long plHashAlg);
        [id(0x00000010), propget, helpstring("Property indicating which encryption algorithm to use when encrypting the message body of a private message.")]
        HRESULT EncryptAlgorithm([out, retval] long* plEncryptAlg);
        [id(0x00000010), propput, helpstring("Property indicating which encryption algorithm to use when encrypting the message body of a private message.")]
        HRESULT EncryptAlgorithm([in] long plEncryptAlg);
        [id(0x00000012), propget, helpstring("Property indicating when the message was sent. The type is Variant Date.")]
        HRESULT SentTime([out, retval] VARIANT* pvarSentTime);
        [id(0x00000013), propget, helpstring("Property indicating when the message arrived at its destination queue. The type is Variant Date.")]
        HRESULT ArrivedTime([out, retval] VARIANT* plArrivedTime);
        [id(0x00000014), propget, helpstring("Property indicating the destination queue of the message. Typically used when reading response messages, or messages in machine journals or dead-letter queues.")]
        HRESULT DestinationQueueInfo([out, retval] IMSMQQueueInfo** ppqinfoDest);
        [id(0x00000015), propget, helpstring("Property containing the security certificate of a message. The type is an array of bytes.")]
        HRESULT SenderCertificate([out, retval] VARIANT* pvarSenderCert);
        [id(0x00000015), propput, helpstring("Property containing the security certificate of a message. The type is an array of bytes.")]
        HRESULT SenderCertificate([in] VARIANT pvarSenderCert);
        [id(0x00000016), propget, helpstring("Property containing the sender identifier of the message. The type is an array of bytes.")]
        HRESULT SenderId([out, retval] VARIANT* pvarSenderId);
        [id(0x00000017), propget, helpstring("Property indicating what type of identifier is attached to the message. Possible values are defined by MSMQSENDERIDTYPE enumeration.")]
        HRESULT SenderIdType([out, retval] long* plSenderIdType);
        [id(0x00000017), propput, helpstring("Property indicating what type of identifier is attached to the message. Possible values are defined by MSMQSENDERIDTYPE enumeration.")]
        HRESULT SenderIdType([in] long plSenderIdType);
        [id(0x6002002f), helpstring("Method used to send a message to the destination queue. Can optionally be part of a transaction.")]
        HRESULT Send(
                        [in] IMSMQQueue* DestinationQueue, 
                        [in, optional] VARIANT* Transaction);
        [id(0x60020030), helpstring("Method used to associate the current security context with a message.")]
        HRESULT AttachCurrentSecurityContext();
    };

    [
      odl,
      uuid(D7D6E077-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Interface describing outgoing asynchronous Message Queuing events that is used for notification of asynchronous message arrival."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQEvent : IDispatch {
    };

    [
      odl,
      uuid(FD174A80-89CF-11D2-B0F2-00E02C074F6B),
      helpstring("Interface describing MSMQ queue."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQQueueInfo2 : IDispatch {
        [id(00000000), propget, helpstring("Property indicating the identifier of the public queue.")]
        HRESULT QueueGuid([out, retval] BSTR* pbstrGuidQueue);
        [id(0x00000001), propget, helpstring("Property identifying the type of service provided by the queue.")]
        HRESULT ServiceTypeGuid([out, retval] BSTR* pbstrGuidServiceType);
        [id(0x00000001), propput, helpstring("Property identifying the type of service provided by the queue.")]
        HRESULT ServiceTypeGuid([in] BSTR pbstrGuidServiceType);
        [id(0x00000002), propget, helpstring("Property indicating the label of the queue.")]
        HRESULT Label([out, retval] BSTR* pbstrLabel);
        [id(0x00000002), propput, helpstring("Property indicating the label of the queue.")]
        HRESULT Label([in] BSTR pbstrLabel);
        [id(0x00000003), propget, helpstring("Property indicating the pathname (physical location) of the queue.")]
        HRESULT PathName([out, retval] BSTR* pbstrPathName);
        [id(0x00000003), propput, helpstring("Property indicating the pathname (physical location) of the queue.")]
        HRESULT PathName([in] BSTR pbstrPathName);
        [id(0x00000005), propget, helpstring("Property that identifies the queue. The format name of a queue is generated by MSMQ when the queue is created, or generated later by the application.")]
        HRESULT FormatName([out, retval] BSTR* pbstrFormatName);
        [id(0x00000005), propput, helpstring("Property that identifies the queue. The format name of a queue is generated by MSMQ when the queue is created, or generated later by the application.")]
        HRESULT FormatName([in] BSTR pbstrFormatName);
        [id(0x00000006), propget, helpstring("Property indicating whether the queue is transactional or non-transactional. If the queue is transactional, all messages sent to the queue must be part of a transaction.")]
        HRESULT IsTransactional([out, retval] short* pisTransactional);
        [id(0x00000007), propget, helpstring("Property that specifies the privacy level that is required by the queue. The privacy level determines how the queue handles private (encrypted) messages. Possible values are defined by the MQPRIVLEVEL enumeration.")]
        HRESULT PrivLevel([out, retval] long* plPrivLevel);
        [id(0x00000007), propput, helpstring("Property that specifies the privacy level that is required by the queue. The privacy level determines how the queue handles private (encrypted) messages. Possible values are defined by the MQPRIVLEVEL enumeration.")]
        HRESULT PrivLevel([in] long plPrivLevel);
        [id(0x00000008), propget, helpstring("Property that specifies if the messages retrieved from the queue are copied to the queue's journal queue.  Possible values are defined by the MQJOURNAL enumeration.")]
        HRESULT Journal([out, retval] long* plJournal);
        [id(0x00000008), propput, helpstring("Property that specifies if the messages retrieved from the queue are copied to the queue's journal queue.  Possible values are defined by the MQJOURNAL enumeration.")]
        HRESULT Journal([in] long plJournal);
        [id(0x0000000d), propget, helpstring("Property that specifies the maximum size (in kilobytes) of the queue.")]
        HRESULT Quota([out, retval] long* plQuota);
        [id(0x0000000d), propput, helpstring("Property that specifies the maximum size (in kilobytes) of the queue.")]
        HRESULT Quota([in] long plQuota);
        [id(0x00000009), propget, helpstring("Property that specifies the base priority for all messages sent to a public queue.  The queue's base priority has no effect on the order of the messages in the queue, or how messages are read from the queue.")]
        HRESULT BasePriority([out, retval] long* plBasePriority);
        [id(0x00000009), propput, helpstring("Property that specifies the base priority for all messages sent to a public queue.  The queue's base priority has no effect on the order of the messages in the queue, or how messages are read from the queue.")]
        HRESULT BasePriority([in] long plBasePriority);
        [id(0x0000000a), propget, helpstring("Property that indicates the time and date when the queue was created. The type is Variant Date.")]
        HRESULT CreateTime([out, retval] VARIANT* pvarCreateTime);
        [id(0x0000000b), propget, helpstring("Property that indicates the time and date when the queue's properties were last modified. The type is Variant Date.")]
        HRESULT ModifyTime([out, retval] VARIANT* pvarModifyTime);
        [id(0x0000000c), propget, helpstring("Property that specifies whether or not the queue only accepts authenticated messages.  If the authentication level of the message does not match the authentication level of the queue, the message is rejected by the queue.  Possible values are defined by the MQAUTHENTICATE enumeration.")]
        HRESULT Authenticate([out, retval] long* plAuthenticate);
        [id(0x0000000c), propput, helpstring("Property that specifies whether or not the queue only accepts authenticated messages.  If the authentication level of the message does not match the authentication level of the queue, the message is rejected by the queue.  Possible values are defined by the MQAUTHENTICATE enumeration.")]
        HRESULT Authenticate([in] long plAuthenticate);
        [id(0x0000000e), propget, helpstring("Property that specifies the maximum size (in kilobytes) of the journal queue.")]
        HRESULT JournalQuota([out, retval] long* plJournalQuota);
        [id(0x0000000e), propput, helpstring("Property that specifies the maximum size (in kilobytes) of the journal queue.")]
        HRESULT JournalQuota([in] long plJournalQuota);
        [id(0x0000000f), propget, helpstring("Property that indicates who can read messages in the queue. If set to False (the default), all users can send messages to the queue but only the owner of the queue can read messages from it. If set to True,  all users can read messages from the queue.")]
        HRESULT IsWorldReadable([out, retval] short* pisWorldReadable);
        [id(0x60020019), helpstring("Method used to create a new queue. The PathName property is required to create a queue. The FormatName property is updated when the queue is created.  Optional parameters include IsWorldReadable (default set to False) and IsTransactional (default set to False).")]
        HRESULT Create(
                        [in, optional] VARIANT* IsTransactional, 
                        [in, optional] VARIANT* IsWorldReadable);
        [id(0x6002001a), helpstring("Method used to delete queue. The PathName propety must be specified to delete a queue.")]
        HRESULT Delete();
        [id(0x6002001b), helpstring("Method used to open a queue. The PathName property must be specified to open a queue. Parameters include Access (send, peek, or receive) and ShareMode (exclusive or all).")]
        HRESULT Open(
                        [in] long Access, 
                        [in] long ShareMode, 
                        [out, retval] IMSMQQueue2** ppq);
        [id(0x6002001c), helpstring("Method used to refresh the properties of a public queue from Active Directory.")]
        HRESULT Refresh();
        [id(0x6002001d), helpstring("Method used to update Active Directory with the public queue's current properties.")]
        HRESULT Update();
        [id(0x00000010), propget, helpstring("Property indicating the pathname (physical location) of the queue. The computer portion of the pathname is in DNS format.")]
        HRESULT PathNameDNS([out, retval] BSTR* pbstrPathNameDNS);
        [id(0x00000011), propget, hidden]
        HRESULT Properties([out, retval] IDispatch** ppcolProperties);
        [id(0x00000012), propget, hidden]
        HRESULT Security([out, retval] VARIANT* pvarSecurity);
        [id(0x00000012), propput, hidden]
        HRESULT Security([in] VARIANT pvarSecurity);
    };

    [
      odl,
      uuid(EF0574E0-06D8-11D3-B100-00E02C074F6B),
      helpstring("Interface describing an open queue: supports message retrieval."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQQueue2 : IDispatch {
        [id(0x00000001), propget, helpstring("Property indicating the access mode of a queue. Possible values are defined by MQACCESS enumeration.")]
        HRESULT Access([out, retval] long* plAccess);
        [id(0x00000002), propget, helpstring("Property indicating the share mode of a queue. Possible values are defined by MQSHARE enumeration.")]
        HRESULT ShareMode([out, retval] long* plShareMode);
        [id(0x00000003), propget, helpstring("Property referring to an MSMQQueueInfo instance describing the queue.")]
        HRESULT QueueInfo([out, retval] IMSMQQueueInfo2** ppqinfo);
        [id(00000000), propget, helpstring("Property indicating the internal handle of an open queue instance.  Useful for directly calling Message Queuing APIs.")]
        HRESULT Handle([out, retval] long* plHandle);
        [id(0x00000004), propget, helpstring("Property indicating whether or not the queue object refers to an open instance of a queue.")]
        HRESULT IsOpen([out, retval] short* pisOpen);
        [id(0x60020005), helpstring("Method to close an open instance of a queue.")]
        HRESULT Close();
        [id(0x60020006), hidden, helpstring("Method to synchronously retrieve a message from a queue. It always removes the first message in the queue regardless of the position of the implicit cursor. Optional parameters include ReceiveTimeout (default set to INFINITE), Transaction (default set to MTS Transaction), WantDestinationQueue (default set to False), and WantBody (default set to True).")]
        HRESULT Receive_v1(
                        [in, optional] VARIANT* Transaction, 
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [out, retval] IMSMQMessage** ppmsg);
        [id(0x60020007), hidden, helpstring("Method to synchronously peek at the first message in the queue, regardless of the implicit cursor position. Optional parameters include ReceiveTimeout (default set to INFINITE), WantDestinationQueue (default set to False), and WantBody (default set to True).")]
        HRESULT Peek_v1(
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [out, retval] IMSMQMessage** ppmsg);
        [id(0x60020008), helpstring("Method to enable asynchronous notification of arriving messages. It can use the queue's implicit cursor.  The user-defined MSMQEvent_Arrived event handler is invoked when a message arrives at the location specified by the optional Cursor parameter (default is first message in the queue), or a timeout occurs. The user-defined MSMQEvent_ArrivedError is invoked if the asynchronous message retrieval results in an error.")]
        HRESULT EnableNotification(
                        [in] IMSMQEvent2* Event, 
                        [in, optional] VARIANT* Cursor, 
                        [in, optional] VARIANT* ReceiveTimeout);
        [id(0x60020009), helpstring("Method that resets the queue's implicit cursor to the beginning of the queue.")]
        HRESULT Reset();
        [id(0x6002000a), hidden, helpstring("Method to synchronously remove the current message from the queue. Retrieves the message at the position pointed to by the implicit cursor. Optional parameters include ReceiveTimeout (default set to INFINITE), Transaction (default set to MTS Transaction), WantDestinationQueue (default set to False), and WantBody (default set to True).")]
        HRESULT ReceiveCurrent_v1(
                        [in, optional] VARIANT* Transaction, 
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [out, retval] IMSMQMessage** ppmsg);
        [id(0x6002000b), hidden, helpstring("Method to synchronously peek at the next message in the queue. When called, the implicit cursor is first advanced and then the message is returned. Optional parameters include ReceiveTimeout (default set to INFINITE), WantDestinationQueue (default set to False), and WantBody (default set to True).")]
        HRESULT PeekNext_v1(
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [out, retval] IMSMQMessage** ppmsg);
        [id(0x6002000c), hidden, helpstring("Method to synchronously peek at the current message in the queue (the message pointed at by the implicit cursor). The implicit cursor is not advanced. Optional parameters include ReceiveTimeout (default set to INFINITE), WantDestinationQueue (default set to False), and WantBody (default set to True).")]
        HRESULT PeekCurrent_v1(
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [out, retval] IMSMQMessage** ppmsg);
        [id(0x6002000d), helpstring("Method to synchronously retrieve a message from a queue. It always removes the first message in queue regardless of the position of the implicit cursor. Optional parameters include ReceiveTimeout (default set to INFINITE), Transaction (default set to MTS Transaction), WantDestinationQueue (default set to False), WantBody (default set to True), and WantConnectorType (default set to False).")]
        HRESULT Receive(
                        [in, optional] VARIANT* Transaction, 
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [in, optional] VARIANT* WantConnectorType, 
                        [out, retval] IMSMQMessage2** ppmsg);
        [id(0x6002000e), helpstring("Method to synchronously peek at the first message in the queue, regardless of the implicit cursor position. Optional parameters include ReceiveTimeout (default set to INFINITE), WantDestinationQueue (default set to False), WantBody (default set to True), and WantConnectorType (default set to False).")]
        HRESULT Peek(
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [in, optional] VARIANT* WantConnectorType, 
                        [out, retval] IMSMQMessage2** ppmsg);
        [id(0x6002000f), helpstring("Method to synchronously remove the current message from the queue. Retrieves the message at the position pointed to by the implicit cursor. Optional parameters include ReceiveTimeout (default set to INFINITE), Transaction (default set to MTS Transaction), WantDestinationQueue (default set to False), WantBody (default set to True), and WantConnectorType (default set to False).")]
        HRESULT ReceiveCurrent(
                        [in, optional] VARIANT* Transaction, 
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [in, optional] VARIANT* WantConnectorType, 
                        [out, retval] IMSMQMessage2** ppmsg);
        [id(0x60020010), helpstring("Method to synchronously peek at the next message in the queue. When called, the implicit cursor is first advanced and then the message is returned. Optional parameters include ReceiveTimeout (default set to INFINITE), WantDestinationQueue (default set to False), WantBody (default set to True), and WantConnectorType (default set to False).")]
        HRESULT PeekNext(
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [in, optional] VARIANT* WantConnectorType, 
                        [out, retval] IMSMQMessage2** ppmsg);
        [id(0x60020011), helpstring("Method to synchronously peek at the current message in queue (message pointed at by the implicit cursor). The implicit cursor is not advanced. Optional parameters include ReceiveTimeout (default set to INFINITE), WantDestinationQueue (default set to False), WantBody (default set to True), and WantConnectorType (default set to False).")]
        HRESULT PeekCurrent(
                        [in, optional] VARIANT* WantDestinationQueue, 
                        [in, optional] VARIANT* WantBody, 
                        [in, optional] VARIANT* ReceiveTimeout, 
                        [in, optional] VARIANT* WantConnectorType, 
                        [out, retval] IMSMQMessage2** ppmsg);
        [id(0x00000005), propget, hidden]
        HRESULT Properties([out, retval] IDispatch** ppcolProperties);
    };

    [
      odl,
      uuid(EBA96B12-2168-11D3-898C-00E02C074F6B),
      helpstring("Interface describing outgoing asynchronous Message Queuing events that is used for notification of asynchronous message arrival."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQEvent2 : IMSMQEvent {
        [id(00000000), propget, hidden]
        HRESULT Properties([out, retval] IDispatch** ppcolProperties);
    };

    [
      odl,
      uuid(D9933BE0-A567-11D2-B0F3-00E02C074F6B),
      helpstring("Interface describing a message. A message can be created and sent to a queue or obtained from a queue."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQMessage2 : IDispatch {
        [id(0x00000007), propget, hidden, helpstring("Property indicating the class of message. Possible values are defined by MQMSGCLASS enumeration")]
        HRESULT Class([out, retval] long* plClass);
        [id(0x00000019), propget, helpstring("Property indicating the privacy level of a message.  Possible values are defined by MQMSGPRIVLEVEL enumeration.")]
        HRESULT PrivLevel([out, retval] long* plPrivLevel);
        [id(0x00000019), propput, helpstring("Property indicating the privacy level of a message.  Possible values are defined by MQMSGPRIVLEVEL enumeration.")]
        HRESULT PrivLevel([in] long plPrivLevel);
        [id(0x0000001a), propget, helpstring("Property indicating the authorization level of a message. Possible values are defined by MQMSGAUTHLEVEL enumeration.")]
        HRESULT AuthLevel([out, retval] long* plAuthLevel);
        [id(0x0000001a), propput, helpstring("Property indicating the authorization level of a message. Possible values are defined by MQMSGAUTHLEVEL enumeration.")]
        HRESULT AuthLevel([in] long plAuthLevel);
        [id(0x0000001b), propget, helpstring("Property indicating whether a message was authenticated or not.")]
        HRESULT IsAuthenticated([out, retval] short* pisAuthenticated);
        [id(0x00000001), propget, helpstring("Property indicating the delivery mode of a message. Possible values defined by MQMSGDELIVERY enumeration.")]
        HRESULT Delivery([out, retval] long* plDelivery);
        [id(0x00000001), propput, helpstring("Property indicating the delivery mode of a message. Possible values defined by MQMSGDELIVERY enumeration.")]
        HRESULT Delivery([in] long plDelivery);
        [id(0x00000018), propget, helpstring("Property indicating the tracing option for a message. Possible values are defined by MQMSGTRACE enumeration.")]
        HRESULT Trace([out, retval] long* plTrace);
        [id(0x00000018), propput, helpstring("Property indicating the tracing option for a message. Possible values are defined by MQMSGTRACE enumeration.")]
        HRESULT Trace([in] long plTrace);
        [id(0x00000002), propget, helpstring("Property indicating the priority level of a message. The range must be between MQ_MIN_PRIORITY and MQ_MAX_PRIORITY.")]
        HRESULT Priority([out, retval] long* plPriority);
        [id(0x00000002), propput, helpstring("Property indicating the priority level of a message. The range must be between MQ_MIN_PRIORITY and MQ_MAX_PRIORITY.")]
        HRESULT Priority([in] long plPriority);
        [id(0x00000003), propget, helpstring("Property indicating the journaling option for a message.  Possible values are defined by MQMSGJOURNAL enumeration.")]
        HRESULT Journal([out, retval] long* plJournal);
        [id(0x00000003), propput, helpstring("Property indicating the journaling option for a message.  Possible values are defined by MQMSGJOURNAL enumeration.")]
        HRESULT Journal([in] long plJournal);
        [id(0x00000004), propget, hidden, helpstring("Property indicating the response queue for the message.")]
        HRESULT ResponseQueueInfo_v1([out, retval] IMSMQQueueInfo** ppqinfoResponse);
        [id(0x00000004), propputref, hidden, helpstring("Property indicating the response queue for the message.")]
        HRESULT ResponseQueueInfo_v1([in] IMSMQQueueInfo* ppqinfoResponse);
        [id(0x00000005), propget, helpstring("Property containing application-specific information.")]
        HRESULT AppSpecific([out, retval] long* plAppSpecific);
        [id(0x00000005), propput, helpstring("Property containing application-specific information.")]
        HRESULT AppSpecific([in] long plAppSpecific);
        [id(0x00000006), propget, helpstring("Property identifying the computer where the message originated.")]
        HRESULT SourceMachineGuid([out, retval] BSTR* pbstrGuidSrcMachine);
        [id(0x0000000d), propget, helpstring("Property indicating the length (in bytes) of the message body.")]
        HRESULT BodyLength([out, retval] long* pcbBody);
        [id(00000000), propget, helpstring("Property containing the message body.  It is of Variant type and can contain any intrinsic type and persistent object.")]
        HRESULT Body([out, retval] VARIANT* pvarBody);
        [id(00000000), propput, helpstring("Property containing the message body.  It is of Variant type and can contain any intrinsic type and persistent object.")]
        HRESULT Body([in] VARIANT pvarBody);
        [id(0x00000008), propget, hidden, helpstring("Property indicating the administration queue for the message.")]
        HRESULT AdminQueueInfo_v1([out, retval] IMSMQQueueInfo** ppqinfoAdmin);
        [id(0x00000008), propputref, hidden, helpstring("Property indicating the administration queue for the message.")]
        HRESULT AdminQueueInfo_v1([in] IMSMQQueueInfo* ppqinfoAdmin);
        [id(0x00000009), propget, helpstring("Property containing the MSMQ-generated identifier (array of bytes) for the message.")]
        HRESULT Id([out, retval] VARIANT* pvarMsgId);
        [id(0x0000000a), propget, helpstring("Property indicating the correlation identifier (array of bytes) for the message.")]
        HRESULT CorrelationId([out, retval] VARIANT* pvarMsgId);
        [id(0x0000000a), propput, helpstring("Property indicating the correlation identifier (array of bytes) for the message.")]
        HRESULT CorrelationId([in] VARIANT pvarMsgId);
        [id(0x0000000b), propget, helpstring("Property indicating what kind of acknowledgement message is returned. Possible values are defined by MQMSGACKNOWLEDGEMENT enumeration.")]
        HRESULT Ack([out, retval] long* plAck);
        [id(0x0000000b), propput, helpstring("Property indicating what kind of acknowledgement message is returned. Possible values are defined by MQMSGACKNOWLEDGEMENT enumeration.")]
        HRESULT Ack([in] long plAck);
        [id(0x0000000c), propget, helpstring("Property indicating the label of the message.")]
        HRESULT Label([out, retval] BSTR* pbstrLabel);
        [id(0x0000000c), propput, helpstring("Property indicating the label of the message.")]
        HRESULT Label([in] BSTR pbstrLabel);
        [id(0x0000000e), propget, helpstring("Property indicating the amount of time allowed to deliver the message to its destination queue.")]
        HRESULT MaxTimeToReachQueue([out, retval] long* plMaxTimeToReachQueue);
        [id(0x0000000e), propput, helpstring("Property indicating the amount of time allowed to deliver the message to its destination queue.")]
        HRESULT MaxTimeToReachQueue([in] long plMaxTimeToReachQueue);
        [id(0x0000000f), propget, helpstring("Property indicating the amount of time the receiving application has to retreive the message from its destination queue.")]
        HRESULT MaxTimeToReceive([out, retval] long* plMaxTimeToReceive);
        [id(0x0000000f), propput, helpstring("Property indicating the amount of time the receiving application has to retreive the message from its destination queue.")]
        HRESULT MaxTimeToReceive([in] long plMaxTimeToReceive);
        [id(0x00000011), propget, helpstring("Property indicating which hash algorithm to use when authenticating the message.")]
        HRESULT HashAlgorithm([out, retval] long* plHashAlg);
        [id(0x00000011), propput, helpstring("Property indicating which hash algorithm to use when authenticating the message.")]
        HRESULT HashAlgorithm([in] long plHashAlg);
        [id(0x00000010), propget, helpstring("Property indicating which encryption algorithm to use when encrypting the message body of a private message.")]
        HRESULT EncryptAlgorithm([out, retval] long* plEncryptAlg);
        [id(0x00000010), propput, helpstring("Property indicating which encryption algorithm to use when encrypting the message body of a private message.")]
        HRESULT EncryptAlgorithm([in] long plEncryptAlg);
        [id(0x00000012), propget, helpstring("Property indicating when the message was sent. The type is Variant Date.")]
        HRESULT SentTime([out, retval] VARIANT* pvarSentTime);
        [id(0x00000013), propget, helpstring("Property indicating when the message arrived at its destination queue. The type is Variant Date.")]
        HRESULT ArrivedTime([out, retval] VARIANT* plArrivedTime);
        [id(0x00000014), propget, helpstring("Property indicating the destination queue of the message. Typically used when reading response messages, or messages in machine journals or dead-letter queues.")]
        HRESULT DestinationQueueInfo([out, retval] IMSMQQueueInfo2** ppqinfoDest);
        [id(0x00000015), propget, helpstring("Property containing the security certificate of a message. The type is an array of bytes.")]
        HRESULT SenderCertificate([out, retval] VARIANT* pvarSenderCert);
        [id(0x00000015), propput, helpstring("Property containing the security certificate of a message. The type is an array of bytes.")]
        HRESULT SenderCertificate([in] VARIANT pvarSenderCert);
        [id(0x00000016), propget, helpstring("Property containing the sender identifier of the message. The type is an array of bytes.")]
        HRESULT SenderId([out, retval] VARIANT* pvarSenderId);
        [id(0x00000017), propget, helpstring("Property indicating what type of identifier is attached to the message. Possible values are defined by MSMQSENDERIDTYPE enumeration.")]
        HRESULT SenderIdType([out, retval] long* plSenderIdType);
        [id(0x00000017), propput, helpstring("Property indicating what type of identifier is attached to the message. Possible values are defined by MSMQSENDERIDTYPE enumeration.")]
        HRESULT SenderIdType([in] long plSenderIdType);
        [id(0x6002002f), helpstring("Method used to send a message to the destination queue. Can optionally be part of a transaction.")]
        HRESULT Send(
                        [in] IMSMQQueue2* DestinationQueue, 
                        [in, optional] VARIANT* Transaction);
        [id(0x60020030), helpstring("Method used to associate the current security context with a message.")]
        HRESULT AttachCurrentSecurityContext();
        [id(0x0000001c), propget, helpstring("Property indicating the software version of MSMQ used to send the message.")]
        HRESULT SenderVersion([out, retval] long* plSenderVersion);
        [id(0x0000001d), propget, helpstring("Property that provides a place to put additional information that is associated with the message. Type is an array of bytes.")]
        HRESULT Extension([out, retval] VARIANT* pvarExtension);
        [id(0x0000001d), propput, helpstring("Property that provides a place to put additional information that is associated with the message. Type is an array of bytes.")]
        HRESULT Extension([in] VARIANT pvarExtension);
        [id(0x0000001e), propget, helpstring("Property indicating that some message properties typically generated by MSMQ are generated externally from MSMQ.")]
        HRESULT ConnectorTypeGuid([out, retval] BSTR* pbstrGuidConnectorType);
        [id(0x0000001e), propput, helpstring("Property indicating that some message properties typically generated by MSMQ are generated externally from MSMQ.")]
        HRESULT ConnectorTypeGuid([in] BSTR pbstrGuidConnectorType);
        [id(0x0000001f), propget, helpstring("Property identifying the transaction status queue on the source computer.")]
        HRESULT TransactionStatusQueueInfo([out, retval] IMSMQQueueInfo2** ppqinfoXactStatus);
        [id(0x00000020), propget, helpstring("Property that specifies the symmetric key used to encrypt messages. The type is an array of bytes.")]
        HRESULT DestinationSymmetricKey([out, retval] VARIANT* pvarDestSymmKey);
        [id(0x00000020), propput, helpstring("Property that specifies the symmetric key used to encrypt messages. The type is an array of bytes.")]
        HRESULT DestinationSymmetricKey([in] VARIANT pvarDestSymmKey);
        [id(0x00000021), propget, helpstring("Property that specifies the digital signature used to authenticate the message. The type is an array of bytes.")]
        HRESULT Signature([out, retval] VARIANT* pvarSignature);
        [id(0x00000021), propput, helpstring("Property that specifies the digital signature used to authenticate the message. The type is an array of bytes.")]
        HRESULT Signature([in] VARIANT pvarSignature);
        [id(0x00000022), propget, helpstring("Property that specifies the type of cryptographic service provider used to generate the message's digital signature.")]
        HRESULT AuthenticationProviderType([out, retval] long* plAuthProvType);
        [id(0x00000022), propput, helpstring("Property that specifies the type of cryptographic service provider used to generate the message's digital signature.")]
        HRESULT AuthenticationProviderType([in] long plAuthProvType);
        [id(0x00000023), propget, helpstring("Property that specifies the name of the cryptographic provider used to generate the message's digital signature.")]
        HRESULT AuthenticationProviderName([out, retval] BSTR* pbstrAuthProvName);
        [id(0x00000023), propput, helpstring("Property that specifies the name of the cryptographic provider used to generate the message's digital signature.")]
        HRESULT AuthenticationProviderName([in] BSTR pbstrAuthProvName);
        [id(0x00000016), propput, helpstring("Property containing the sender identifier of the message. The type is an array of bytes.")]
        HRESULT SenderId([in] VARIANT pvarSenderId);
        [id(0x00000024), propget, helpstring("Property indicating the class of message. Possible values are defined by MQMSGCLASS enumeration.")]
        HRESULT MsgClass([out, retval] long* plMsgClass);
        [id(0x00000024), propput, helpstring("Property indicating the class of message. Possible values are defined by MQMSGCLASS enumeration.")]
        HRESULT MsgClass([in] long plMsgClass);
        [id(0x00000025), propget, hidden]
        HRESULT Properties([out, retval] IDispatch** ppcolProperties);
        [id(0x00000026), propget, helpstring("Property that indicates which transaction sent the message. The type is an array of bytes.")]
        HRESULT TransactionId([out, retval] VARIANT* pvarXactId);
        [id(0x00000027), propget, helpstring("Property that indicates whether the message was the first message sent in a transaction.")]
        HRESULT IsFirstInTransaction([out, retval] short* pisFirstInXact);
        [id(0x00000028), propget, helpstring("Property that indicates whether the message was the last message sent in a transaction.")]
        HRESULT IsLastInTransaction([out, retval] short* pisLastInXact);
        [id(0x00000029), propget, helpstring("Property indicating the response queue for the message.")]
        HRESULT ResponseQueueInfo([out, retval] IMSMQQueueInfo2** ppqinfoResponse);
        [id(0x00000029), propputref, helpstring("Property indicating the response queue for the message.")]
        HRESULT ResponseQueueInfo([in] IMSMQQueueInfo2* ppqinfoResponse);
        [id(0x0000002a), propget, helpstring("Property indicating the administration queue for the message.")]
        HRESULT AdminQueueInfo([out, retval] IMSMQQueueInfo2** ppqinfoAdmin);
        [id(0x0000002a), propputref, helpstring("Property indicating the administration queue for the message.")]
        HRESULT AdminQueueInfo([in] IMSMQQueueInfo2* ppqinfoAdmin);
        [id(0x0000002b), propget, helpstring("Property indicating the authentication level of a received message. Possible values are defined by MQMSGAUTHENTICATION enumeration.")]
        HRESULT ReceivedAuthenticationLevel([out, retval] short* psReceivedAuthenticationLevel);
    };

    [
      odl,
      uuid(EBA96B0F-2168-11D3-898C-00E02C074F6B),
      helpstring("Interface describing the collection of queues produced by MSMQQuery.LookupQueue."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQQueueInfos2 : IDispatch {
        [id(0x60020000), helpstring("Method used to reset the implicit cursor to the start of a collection of queues produced by MSMQQuery.LookupQueue.")]
        HRESULT Reset();
        [id(0x60020001), helpstring("Method used to advance the implicit cursor to the next element of a collection of queues produced by MSMQQuery.LookupQueue.")]
        HRESULT Next([out, retval] IMSMQQueueInfo2** ppqinfoNext);
        [id(00000000), propget, hidden]
        HRESULT Properties([out, retval] IDispatch** ppcolProperties);
    };

    [
      odl,
      uuid(D7D6E07F-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Interface describing the MSMQ transaction object. Supports the standard ITransaction methods Commit and Abort."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQTransaction : IDispatch {
        [id(00000000), propget, helpstring("Property that indicates the underlying "magic cookie" used by a transaction dispenser. ")]
        HRESULT Transaction([out, retval] long* plTransaction);
        [id(0x60020001), helpstring("Method used to commit an MSMQ transaction.")]
        HRESULT Commit(
                        [in, optional] VARIANT* fRetaining, 
                        [in, optional] VARIANT* grfTC, 
                        [in, optional] VARIANT* grfRM);
        [id(0x60020002), helpstring("Method used to abort an MSMQ transaction.")]
        HRESULT Abort(
                        [in, optional] VARIANT* fRetaining, 
                        [in, optional] VARIANT* fAsync);
    };

    [
      odl,
      uuid(D7D6E081-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Interface describing DTCtransaction dispenser. Supports creating new DTC transactions."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQCoordinatedTransactionDispenser : IDispatch {
        [id(0x60020000), helpstring("Method used to obtain a new transaction from a transaction dispenser.")]
        HRESULT BeginTransaction([out, retval] IMSMQTransaction** ptransaction);
    };

    [
      odl,
      uuid(D7D6E083-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Interface describing the MSMQ transaction dispenser.  Supports creating new MSMQ internal transactions."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQTransactionDispenser : IDispatch {
        [id(0x60020000), helpstring("Method used to obtain a new transaction from a transaction dispenser.")]
        HRESULT BeginTransaction([out, retval] IMSMQTransaction** ptransaction);
    };

    typedef [helpstring("Enumerates the various hashing and encryption algorithms.")]
    enum {
        MQMSG_CALG_MD2 = 32769,
        MQMSG_CALG_MD4 = 32770,
        MQMSG_CALG_MD5 = 32771,
        MQMSG_CALG_SHA = 32772,
        MQMSG_CALG_MAC = 32773,
        MQMSG_CALG_RSA_SIGN = 9216,
        MQMSG_CALG_DSS_SIGN = 8704,
        MQMSG_CALG_RSA_KEYX = 41984,
        MQMSG_CALG_DES = 26113,
        MQMSG_CALG_RC2 = 26114,
        MQMSG_CALG_RC4 = 26625,
        MQMSG_CALG_SEAL = 26626
    } MQCALG;

    typedef [helpstring("Enumerates the transaction options when sending and receiving a message.")]
    enum {
        MQ_NO_TRANSACTION = 0,
        MQ_MTS_TRANSACTION = 1,
        MQ_XA_TRANSACTION = 2,
        MQ_SINGLE_MESSAGE = 3
    } MQTRANSACTION;

    typedef [helpstring("Enumerates the relational operators for a query.")]
    enum {
        REL_NOP = 0,
        REL_EQ = 1,
        REL_NEQ = 2,
        REL_LT = 3,
        REL_GT = 4,
        REL_LE = 5,
        REL_GE = 6
    } RELOPS;

    typedef [helpstring("Enumerates the flags when registering a certificate.")]
    enum {
        MQCERT_REGISTER_ALWAYS = 1,
        MQCERT_REGISTER_IF_NOT_EXIST = 2
    } MQCERT_REGISTER;

    typedef [helpstring("Enumerates the cursor operations when synchronously or asynchronously peeking at or retrieving a message.")]
    enum {
        MQMSG_FIRST = 0,
        MQMSG_CURRENT = 1,
        MQMSG_NEXT = 2
    } MQMSGCURSOR;

    typedef [helpstring("Enumerates the classes of a message.")]
    enum {
        MQMSG_CLASS_NORMAL = 0,
        MQMSG_CLASS_REPORT = 1,
        MQMSG_CLASS_ACK_REACH_QUEUE = 2,
        MQMSG_CLASS_ACK_RECEIVE = 16384,
        MQMSG_CLASS_NACK_BAD_DST_Q = 32768,
        MQMSG_CLASS_NACK_PURGED = 32769,
        MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT = 32770,
        MQMSG_CLASS_NACK_Q_EXCEED_QUOTA = 32771,
        MQMSG_CLASS_NACK_ACCESS_DENIED = 32772,
        MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED = 32773,
        MQMSG_CLASS_NACK_BAD_SIGNATURE = 32774,
        MQMSG_CLASS_NACK_BAD_ENCRYPTION = 32775,
        MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT = 32776,
        MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q = 32777,
        MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG = 32778,
        MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER = 32779,
        MQMSG_CLASS_NACK_Q_DELETED = 49152,
        MQMSG_CLASS_NACK_Q_PURGED = 49153,
        MQMSG_CLASS_NACK_RECEIVE_TIMEOUT = 49154,
        MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER = 49155
    } MQMSGCLASS;

    typedef [helpstring("Enumerates the delivery modes of a message.")]
    enum {
        MQMSG_DELIVERY_EXPRESS = 0,
        MQMSG_DELIVERY_RECOVERABLE = 1
    } MQMSGDELIVERY;

    typedef [helpstring("Enumerates the acknowledgement modes for a message.")]
    enum {
        MQMSG_ACKNOWLEDGMENT_NONE = 0,
        MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL = 1,
        MQMSG_ACKNOWLEDGMENT_POS_RECEIVE = 2,
        MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL = 4,
        MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE = 8,
        MQMSG_ACKNOWLEDGMENT_NACK_REACH_QUEUE = 4,
        MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE = 5,
        MQMSG_ACKNOWLEDGMENT_NACK_RECEIVE = 12,
        MQMSG_ACKNOWLEDGMENT_FULL_RECEIVE = 14
    } MQMSGACKNOWLEDGEMENT;

    typedef [helpstring("Enumerates the journaling for a message.")]
    enum {
        MQMSG_JOURNAL_NONE = 0,
        MQMSG_DEADLETTER = 1,
        MQMSG_JOURNAL = 2
    } MQMSGJOURNAL;

    typedef [helpstring("Enumerates the tracing options for a message.")]
    enum {
        MQMSG_TRACE_NONE = 0,
        MQMSG_SEND_ROUTE_TO_REPORT_QUEUE = 1
    } MQMSGTRACE;

    typedef [helpstring("Enumerates the sender identifier types for a message.")]
    enum {
        MQMSG_SENDERID_TYPE_NONE = 0,
        MQMSG_SENDERID_TYPE_SID = 1
    } MQMSGSENDERIDTYPE;

    typedef [helpstring("Enumerates the privacy levels for a message.")]
    enum {
        MQMSG_PRIV_LEVEL_NONE = 0,
        MQMSG_PRIV_LEVEL_BODY = 1,
        MQMSG_PRIV_LEVEL_BODY_BASE = 1,
        MQMSG_PRIV_LEVEL_BODY_ENHANCED = 3
    } MQMSGPRIVLEVEL;

    typedef [helpstring("Enumerates the authorization levels for a message.")]
    enum {
        MQMSG_AUTH_LEVEL_NONE = 0,
        MQMSG_AUTH_LEVEL_ALWAYS = 1,
        MQMSG_AUTH_LEVEL_MSMQ10 = 2,
        MQMSG_AUTH_LEVEL_MSMQ20 = 4
    } MQMSGAUTHLEVEL;

    typedef [helpstring("Enumerates message identification property sizes.")]
    enum {
        MQMSG_MSGID_SIZE = 20,
        MQMSG_CORRELATIONID_SIZE = 20,
        MQMSG_XACTID_SIZE = 20
    } MQMSGIDSIZE;

    typedef [helpstring("Enumerates the maximum length for the message label.")]
    enum {
        MQ_MAX_MSG_LABEL_LEN = 249
    } MQMSGMAX;

    typedef [helpstring("Enumerates the authentication levels of a received message.")]
    enum {
        MQMSG_AUTHENTICATION_NOT_REQUESTED = 0,
        MQMSG_AUTHENTICATION_REQUESTED = 1,
        MQMSG_AUTHENTICATION_REQUESTED_EX = 3
    } MQMSGAUTHENTICATION;

    typedef [helpstring("Enumerates the sharing modes for an open queue.")]
    enum {
        MQ_DENY_NONE = 0,
        MQ_DENY_RECEIVE_SHARE = 1
    } MQSHARE;

    typedef [helpstring("Enumerates the access (send, peek, receive) modes for an open queue.")]
    enum {
        MQ_RECEIVE_ACCESS = 1,
        MQ_SEND_ACCESS = 2,
        MQ_PEEK_ACCESS = 32
    } MQACCESS;

    typedef [helpstring("Enumerates the journaling modes for a queue.")]
    enum {
        MQ_JOURNAL_NONE = 0,
        MQ_JOURNAL = 1
    } MQJOURNAL;

    typedef [helpstring("Enumerates the transactional modes for a queue.")]
    enum {
        MQ_TRANSACTIONAL_NONE = 0,
        MQ_TRANSACTIONAL = 1
    } MQTRANSACTIONAL;

    typedef [helpstring("Enumerates the authentication modes for a queue.")]
    enum {
        MQ_AUTHENTICATE_NONE = 0,
        MQ_AUTHENTICATE = 1
    } MQAUTHENTICATE;

    typedef [helpstring("Enumerates the privacy levels for a queue.")]
    enum {
        MQ_PRIV_LEVEL_NONE = 0,
        MQ_PRIV_LEVEL_OPTIONAL = 1,
        MQ_PRIV_LEVEL_BODY = 2
    } MQPRIVLEVEL;

    typedef [helpstring("Enumerates the minimum and maximum queue priorities.")]
    enum {
        MQ_MIN_PRIORITY = 0,
        MQ_MAX_PRIORITY = 7
    } MQPRIORITY;

    typedef [helpstring("Enumerates the maximum length for a queue label and pathname.")]
    enum {
        MQ_MAX_Q_NAME_LEN = 124,
        MQ_MAX_Q_LABEL_LEN = 124
    } MQMAX;

    typedef [helpstring("Enumerates the default values for message and queue properties.")]
    enum {
        DEFAULT_M_PRIORITY = 3,
        DEFAULT_M_DELIVERY = 0,
        DEFAULT_M_ACKNOWLEDGE = 0,
        DEFAULT_M_JOURNAL = 0,
        DEFAULT_M_APPSPECIFIC = 0,
        DEFAULT_M_PRIV_LEVEL = 0,
        DEFAULT_M_AUTH_LEVEL = 0,
        DEFAULT_M_SENDERID_TYPE = 1,
        DEFAULT_Q_JOURNAL = 0,
        DEFAULT_Q_BASEPRIORITY = 0,
        DEFAULT_Q_QUOTA = 0xffffffff,
        DEFAULT_Q_JOURNAL_QUOTA = 0xffffffff,
        DEFAULT_Q_TRANSACTION = 0,
        DEFAULT_Q_AUTHENTICATE = 0,
        DEFAULT_Q_PRIV_LEVEL = 1
    } MQDEFAULT;

    typedef [helpstring("Enumerates all Message Queuing errors.")]
    enum {
        MQ_ERROR = 0xc00e0001,
        MQ_ERROR_PROPERTY = 0xc00e0002,
        MQ_ERROR_QUEUE_NOT_FOUND = 0xc00e0003,
        MQ_ERROR_QUEUE_EXISTS = 0xc00e0005,
        MQ_ERROR_INVALID_PARAMETER = 0xc00e0006,
        MQ_ERROR_INVALID_HANDLE = 0xc00e0007,
        MQ_ERROR_OPERATION_CANCELLED = 0xc00e0008,
        MQ_ERROR_SHARING_VIOLATION = 0xc00e0009,
        MQ_ERROR_SERVICE_NOT_AVAILABLE = 0xc00e000b,
        MQ_ERROR_MACHINE_NOT_FOUND = 0xc00e000d,
        MQ_ERROR_ILLEGAL_SORT = 0xc00e0010,
        MQ_ERROR_ILLEGAL_USER = 0xc00e0011,
        MQ_ERROR_NO_DS = 0xc00e0013,
        MQ_ERROR_ILLEGAL_QUEUE_PATHNAME = 0xc00e0014,
        MQ_ERROR_ILLEGAL_PROPERTY_VALUE = 0xc00e0018,
        MQ_ERROR_ILLEGAL_PROPERTY_VT = 0xc00e0019,
        MQ_ERROR_BUFFER_OVERFLOW = 0xc00e001a,
        MQ_ERROR_IO_TIMEOUT = 0xc00e001b,
        MQ_ERROR_ILLEGAL_CURSOR_ACTION = 0xc00e001c,
        MQ_ERROR_MESSAGE_ALREADY_RECEIVED = 0xc00e001d,
        MQ_ERROR_ILLEGAL_FORMATNAME = 0xc00e001e,
        MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL = 0xc00e001f,
        MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION = 0xc00e0020,
        MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR = 0xc00e0021,
        MQ_ERROR_SENDERID_BUFFER_TOO_SMALL = 0xc00e0022,
        MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL = 0xc00e0023,
        MQ_ERROR_CANNOT_IMPERSONATE_CLIENT = 0xc00e0024,
        MQ_ERROR_ACCESS_DENIED = 0xc00e0025,
        MQ_ERROR_PRIVILEGE_NOT_HELD = 0xc00e0026,
        MQ_ERROR_INSUFFICIENT_RESOURCES = 0xc00e0027,
        MQ_ERROR_USER_BUFFER_TOO_SMALL = 0xc00e0028,
        MQ_ERROR_MESSAGE_STORAGE_FAILED = 0xc00e002a,
        MQ_ERROR_SENDER_CERT_BUFFER_TOO_SMALL = 0xc00e002b,
        MQ_ERROR_INVALID_CERTIFICATE = 0xc00e002c,
        MQ_ERROR_CORRUPTED_INTERNAL_CERTIFICATE = 0xc00e002d,
        MQ_ERROR_INTERNAL_USER_CERT_EXIST = 0xc00e002e,
        MQ_ERROR_NO_INTERNAL_USER_CERT = 0xc00e002f,
        MQ_ERROR_CORRUPTED_SECURITY_DATA = 0xc00e0030,
        MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE = 0xc00e0031,
        MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION = 0xc00e0033,
        MQ_ERROR_BAD_SECURITY_CONTEXT = 0xc00e0035,
        MQ_ERROR_COULD_NOT_GET_USER_SID = 0xc00e0036,
        MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO = 0xc00e0037,
        MQ_ERROR_ILLEGAL_MQCOLUMNS = 0xc00e0038,
        MQ_ERROR_ILLEGAL_PROPID = 0xc00e0039,
        MQ_ERROR_ILLEGAL_RELATION = 0xc00e003a,
        MQ_ERROR_ILLEGAL_PROPERTY_SIZE = 0xc00e003b,
        MQ_ERROR_ILLEGAL_RESTRICTION_PROPID = 0xc00e003c,
        MQ_ERROR_ILLEGAL_MQQUEUEPROPS = 0xc00e003d,
        MQ_ERROR_PROPERTY_NOTALLOWED = 0xc00e003e,
        MQ_ERROR_INSUFFICIENT_PROPERTIES = 0xc00e003f,
        MQ_ERROR_MACHINE_EXISTS = 0xc00e0040,
        MQ_ERROR_ILLEGAL_MQQMPROPS = 0xc00e0041,
        MQ_ERROR_DS_IS_FULL = 0xc00e0042,
        MQ_ERROR_DS_ERROR = 0xc00e0043,
        MQ_ERROR_INVALID_OWNER = 0xc00e0044,
        MQ_ERROR_UNSUPPORTED_ACCESS_MODE = 0xc00e0045,
        MQ_ERROR_RESULT_BUFFER_TOO_SMALL = 0xc00e0046,
        MQ_ERROR_DELETE_CN_IN_USE = 0xc00e0048,
        MQ_ERROR_NO_RESPONSE_FROM_OBJECT_SERVER = 0xc00e0049,
        MQ_ERROR_OBJECT_SERVER_NOT_AVAILABLE = 0xc00e004a,
        MQ_ERROR_QUEUE_NOT_AVAILABLE = 0xc00e004b,
        MQ_ERROR_DTC_CONNECT = 0xc00e004c,
        MQ_ERROR_TRANSACTION_IMPORT = 0xc00e004e,
        MQ_ERROR_TRANSACTION_USAGE = 0xc00e0050,
        MQ_ERROR_TRANSACTION_SEQUENCE = 0xc00e0051,
        MQ_ERROR_MISSING_CONNECTOR_TYPE = 0xc00e0055,
        MQ_ERROR_STALE_HANDLE = 0xc00e0056,
        MQ_ERROR_TRANSACTION_ENLIST = 0xc00e0058,
        MQ_ERROR_QUEUE_DELETED = 0xc00e005a,
        MQ_ERROR_ILLEGAL_CONTEXT = 0xc00e005b,
        MQ_ERROR_ILLEGAL_SORT_PROPID = 0xc00e005c,
        MQ_ERROR_LABEL_TOO_LONG = 0xc00e005d,
        MQ_ERROR_LABEL_BUFFER_TOO_SMALL = 0xc00e005e,
        MQ_ERROR_MQIS_SERVER_EMPTY = 0xc00e005f,
        MQ_ERROR_MQIS_READONLY_MODE = 0xc00e0060,
        MQ_ERROR_SYMM_KEY_BUFFER_TOO_SMALL = 0xc00e0061,
        MQ_ERROR_SIGNATURE_BUFFER_TOO_SMALL = 0xc00e0062,
        MQ_ERROR_PROV_NAME_BUFFER_TOO_SMALL = 0xc00e0063,
        MQ_ERROR_ILLEGAL_OPERATION = 0xc00e0064,
        MQ_ERROR_WRITE_NOT_ALLOWED = 0xc00e0065,
        MQ_ERROR_WKS_CANT_SERVE_CLIENT = 0xc00e0066,
        MQ_ERROR_DEPEND_WKS_LICENSE_OVERFLOW = 0xc00e0067,
        MQ_CORRUPTED_QUEUE_WAS_DELETED = 0xc00e0068,
        MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE = 0xc00e0069,
        MQ_ERROR_UNSUPPORTED_OPERATION = 0xc00e006a,
        MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED = 0xc00e006b,
        MQ_ERROR_CANNOT_SET_CRYPTO_SEC_DESCR = 0xc00e006c,
        MQ_ERROR_CERTIFICATE_NOT_PROVIDED = 0xc00e006d,
        MQ_ERROR_Q_DNS_PROPERTY_NOT_SUPPORTED = 0xc00e006e,
        MQ_ERROR_CANT_CREATE_CERT_STORE = 0xc00e006f,
        MQ_ERROR_CANNOT_CREATE_CERT_STORE = 0xc00e006f,
        MQ_ERROR_CANT_OPEN_CERT_STORE = 0xc00e0070,
        MQ_ERROR_CANNOT_OPEN_CERT_STORE = 0xc00e0070,
        MQ_ERROR_ILLEGAL_ENTERPRISE_OPERATION = 0xc00e0071,
        MQ_ERROR_CANNOT_GRANT_ADD_GUID = 0xc00e0072,
        MQ_ERROR_CANNOT_LOAD_MSMQOCM = 0xc00e0073,
        MQ_ERROR_NO_ENTRY_POINT_MSMQOCM = 0xc00e0074,
        MQ_ERROR_NO_MSMQ_SERVERS_ON_DC = 0xc00e0075,
        MQ_ERROR_CANNOT_JOIN_DOMAIN = 0xc00e0076,
        MQ_ERROR_CANNOT_CREATE_ON_GC = 0xc00e0077,
        MQ_ERROR_GUID_NOT_MATCHING = 0xc00e0078,
        MQ_ERROR_PUBLIC_KEY_NOT_FOUND = 0xc00e0079,
        MQ_ERROR_PUBLIC_KEY_DOES_NOT_EXIST = 0xc00e007a,
        MQ_ERROR_ILLEGAL_MQPRIVATEPROPS = 0xc00e007b,
        MQ_ERROR_NO_GC_IN_DOMAIN = 0xc00e007c,
        MQ_ERROR_NO_MSMQ_SERVERS_ON_GC = 0xc00e007d,
        MQ_ERROR_CANNOT_GET_DN = 0xc00e007e,
        MQ_ERROR_CANNOT_HASH_DATA_EX = 0xc00e007f,
        MQ_ERROR_CANNOT_SIGN_DATA_EX = 0xc00e0080,
        MQ_ERROR_CANNOT_CREATE_HASH_EX = 0xc00e0081,
        MQ_ERROR_FAIL_VERIFY_SIGNATURE_EX = 0xc00e0082
    } MQERROR;

    typedef [helpstring("Enumerates all Message Queuing warnings.")]
    enum {
        MQ_INFORMATION_PROPERTY = 0x400e0001,
        MQ_INFORMATION_ILLEGAL_PROPERTY = 0x400e0002,
        MQ_INFORMATION_PROPERTY_IGNORED = 0x400e0003,
        MQ_INFORMATION_UNSUPPORTED_PROPERTY = 0x400e0004,
        MQ_INFORMATION_DUPLICATE_PROPERTY = 0x400e0005,
        MQ_INFORMATION_OPERATION_PENDING = 0x400e0006,
        MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL = 0x400e0009,
        MQ_INFORMATION_INTERNAL_USER_CERT_EXIST = 0x400e000a,
        MQ_INFORMATION_OWNER_IGNORED = 0x400e000b
    } MQWARNING;

    [
      odl,
      uuid(EBA96B0E-2168-11D3-898C-00E02C074F6B),
      helpstring("Interface providing Message Queuing lookup facilities that are used to locate public queues."),
      hidden,
      dual,
      nonextensible,
      oleautomation
    ]
    interface IMSMQQuery2 : IDispatch {
        [id(0x60020000), helpstring("Produces a collection of public queues that match a specified selection criteria. Queries Active Directory.")]
        HRESULT LookupQueue(
                        [in, optional] VARIANT* QueueGuid, 
                        [in, optional] VARIANT* ServiceTypeGuid, 
                        [in, optional] VARIANT* Label, 
                        [in, optional] VARIANT* CreateTime, 
                        [in, optional] VARIANT* ModifyTime, 
                        [in, optional] VARIANT* RelServiceType, 
                        [in, optional] VARIANT* RelLabel, 
                        [in, optional] VARIANT* RelCreateTime, 
                        [in, optional] VARIANT* RelModifyTime, 
                        [out, retval] IMSMQQueueInfos2** ppqinfos);
        [id(00000000), propget, hidden]
        HRESULT Properties([out, retval] IDispatch** ppcolProperties);
    };

    [
      uuid(D7D6E073-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Object providing Message Queuing lookup facilities that are used to locate public queues.")
    ]
    coclass MSMQQuery {
        interface IMSMQQuery;
        [default] interface IMSMQQuery2;
    };

    [
      uuid(D7D6E075-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Object describing a message. A message can be created and sent to a queue or obtained from a queue.")
    ]
    coclass MSMQMessage {
        interface IMSMQMessage;
        [default] interface IMSMQMessage2;
    };

    [
      uuid(D7D6E079-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Object describing an open queue that supports message retrieval.  Obtained by invoking the MSMQQueueInfo.Open method.")
    ]
    coclass MSMQQueue {
        interface IMSMQQueue;
        [default] interface IMSMQQueue2;
    };

    [
      odl,
      uuid(D7AB3341-C9D3-11D1-BB47-0080C7C5A2C0),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQPrivateEvent : IDispatch {
        [id(0x60020000), propget]
        HRESULT Hwnd([out, retval] long* phwnd);
        [id(0x60020001)]
        HRESULT FireArrivedEvent(
                        [in] IMSMQQueue* pq, 
                        [in] long msgcursor);
        [id(0x60020002)]
        HRESULT FireArrivedErrorEvent(
                        [in] IMSMQQueue* pq, 
                        [in] HRESULT hrStatus, 
                        [in] long msgcursor);
    };

    [
      uuid(D7D6E078-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Outgoing event dispinterface that is used to  support asynchronous message notifications."),
      hidden
    ]
    dispinterface _DMSMQEventEvents {
        properties:
        methods:
            [id(00000000), helpstring("User-defined method invoked when a message arrives at a queue.")]
            void Arrived(
                            [in] IDispatch* Queue, 
                            [in] long Cursor);
            [id(0x00000001), helpstring("User-defined method invoked when an error is returned while reading messages asynchronously.")]
            void ArrivedError(
                            [in] IDispatch* Queue, 
                            [in] long ErrorCode, 
                            [in] long Cursor);
    };

    [
      uuid(D7D6E07A-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Object describing outgoing asynchronous events.  Used for notification of asynchronous message arrival.")
    ]
    coclass MSMQEvent {
        interface IMSMQEvent;
        [default] interface IMSMQEvent2;
        interface IMSMQPrivateEvent;
        [default, source] dispinterface _DMSMQEventEvents;
    };

    [
      uuid(D7D6E07C-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Object describing a queue. Used to create, delete, and open queues.")
    ]
    coclass MSMQQueueInfo {
        interface IMSMQQueueInfo;
        [default] interface IMSMQQueueInfo2;
    };

    [
      uuid(D7D6E07E-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Object describing the collection of queues produced by MSMQQuery.LookupQueue.")
    ]
    coclass MSMQQueueInfos {
        interface IMSMQQueueInfos;
        [default] interface IMSMQQueueInfos2;
    };

    typedef struct tagMQBOID {
                
unsigned char rgb[16];
    } MQBOID;

    typedef struct tagMQXACTTRANSINFO {
                
MQBOID uow;
                
long isoLevel;
                
unsigned long isoFlags;
                
unsigned long grfTCSupported;
                
unsigned long grfRMSupported;
                
unsigned long grfTCSupportedRetaining;
                
unsigned long grfRMSupportedRetaining;
    } MQXACTTRANSINFO;

    [
      odl,
      uuid(2CE0C5B0-6E67-11D2-B0E6-00E02C074F6B),
      helpstring("Interface describing the MSMQ transaction object.  Supports the standard ITransaction methods Commit and Abort."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQTransaction2 : IMSMQTransaction {
        [id(0x60030000), helpstring("Method used to initialize a new MSMQ transaction object with an existing transaction.")]
        HRESULT InitNew([in] VARIANT varTransaction);
        [id(0x00000001), propget, hidden]
        HRESULT Properties([out, retval] IDispatch** ppcolProperties);
    };

    [
      uuid(D7D6E080-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Object implementing the MSMQ transaction object. Supports the standard ITransaction methods Commit and Abort.")
    ]
    coclass MSMQTransaction {
        interface IMSMQTransaction;
        [default] interface IMSMQTransaction2;
    };

    [
      odl,
      uuid(EBA96B10-2168-11D3-898C-00E02C074F6B),
      helpstring("Interface describing DTCtransaction dispenser. Supports creating new DTC transactions."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQCoordinatedTransactionDispenser2 : IDispatch {
        [id(0x60020000), helpstring("Method used to obtain a new transaction from a transaction dispenser.")]
        HRESULT BeginTransaction([out, retval] IMSMQTransaction2** ptransaction);
        [id(00000000), propget, hidden]
        HRESULT Properties([out, retval] IDispatch** ppcolProperties);
    };

    [
      uuid(D7D6E082-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Object implementing the DTC transaction dispenser.  Supports creating new DTC transactions.")
    ]
    coclass MSMQCoordinatedTransactionDispenser {
        interface IMSMQCoordinatedTransactionDispenser;
        [default] interface IMSMQCoordinatedTransactionDispenser2;
    };

    [
      odl,
      uuid(EBA96B11-2168-11D3-898C-00E02C074F6B),
      helpstring("Interface describing the MSMQ transaction dispenser.  Supports creating new MSMQ internal transactions."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQTransactionDispenser2 : IDispatch {
        [id(0x60020000), helpstring("Method used to obtain a new transaction from a transaction dispenser.")]
        HRESULT BeginTransaction([out, retval] IMSMQTransaction2** ptransaction);
        [id(00000000), propget, hidden]
        HRESULT Properties([out, retval] IDispatch** ppcolProperties);
    };

    [
      uuid(D7D6E084-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Object implementing the MSMQ transaction dispenser.  Supports creating new MSMQ internal transactions.")
    ]
    coclass MSMQTransactionDispenser {
        interface IMSMQTransactionDispenser;
        [default] interface IMSMQTransactionDispenser2;
    };

    [
      odl,
      uuid(D7D6E085-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Interface describing the MSMQ application object."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQApplication : IDispatch {
        [id(0x60020000), helpstring("Global function used to map a computer pathname to a unique identifier. For example, this identifier can be used to construct a format name for a computer so that its journal queue can be opened.")]
        HRESULT MachineIdOfMachineName(
                        [in] BSTR MachineName, 
                        [out, retval] BSTR* pbstrGuid);
    };

    [
      odl,
      uuid(12A30900-7300-11D2-B0E6-00E02C074F6B),
      helpstring("Interface describing the MSMQ application object."),
      hidden,
      dual,
      oleautomation
    ]
    interface IMSMQApplication2 : IMSMQApplication {
        [id(0x60030000), helpstring("Method used to register a user certificate in Active Directory.")]
        HRESULT RegisterCertificate(
                        [in, optional] VARIANT* Flags, 
                        [in, optional] VARIANT* ExternalCertificate);
        [id(0x60030001), helpstring("Global function used to map a computer unique identifier to a pathname. For example, MSMQMessage.SourceMachineGuid can be mapped to find the computer name from which a message was sent.")]
        HRESULT MachineNameOfMachineId(
                        [in] BSTR bstrGuid, 
                        [out, retval] BSTR* pbstrMachineName);
        [id(0x00000001), propget, helpstring("Global property that indicates the major version of MSMQ")]
        HRESULT MSMQVersionMajor([out, retval] short* psMSMQVersionMajor);
        [id(0x00000002), propget, helpstring("Global property that indicates the minor version of MSMQ")]
        HRESULT MSMQVersionMinor([out, retval] short* psMSMQVersionMinor);
        [id(0x00000003), propget, helpstring("Global property that indicates the build version of MSMQ")]
        HRESULT MSMQVersionBuild([out, retval] short* psMSMQVersionBuild);
        [id(0x00000004), propget, helpstring("Global property that indicates whether MSMQ uses the Active Directory")]
        HRESULT IsDsEnabled([out, retval] VARIANT_BOOL* pfIsDsEnabled);
        [id(00000000), propget, hidden]
        HRESULT Properties([out, retval] IDispatch** ppcolProperties);
    };

    [
      uuid(D7D6E086-DCCD-11D0-AA4B-0060970DEBAE),
      helpstring("Object implementing the MSMQ application object.  Provides global functionality."),
      appobject
    ]
    coclass MSMQApplication {
        interface IMSMQApplication;
        [default] interface IMSMQApplication2;
    };
};
